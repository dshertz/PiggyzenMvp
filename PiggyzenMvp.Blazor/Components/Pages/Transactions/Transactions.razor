@page "/transactions"
@rendermode InteractiveServer
@using System.Linq
@using PiggyzenMvp.Blazor.DTOs
@using PiggyzenMvp.Blazor.DTOs.Transactions
@using PiggyzenMvp.Blazor.Services
@inject IHttpClientFactory HttpClientFactory
@inject Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedLocalStorage BrowserStorage
@inject TransactionFilterState FilterState

<h2>Transaktioner</h2>

<div class="mb-4 d-flex flex-wrap align-items-end gap-3">
    <div>
        <label for="search" class="form-label mb-1">Sök</label>
        <div class="input-group">
            <InputText id="search"
                       class="form-control"
                       @bind-Value="searchText"
                       oninput="this.dispatchEvent(new Event('change'))"
                       @onchange="OnSearchChanged"
                       placeholder="Sök beskrivning..." />
            <span class="input-group-text bg-white">
                <i class="bi bi-search"></i>
            </span>
        </div>
    </div>
    <div>
        <label class="form-label mb-1">Filtrera</label>
        <div class="btn-group" role="group" aria-label="Filter">
            <button type="button"
                    class="btn btn-outline-primary @(filterStateLoaded && filterCategory == "all" ? "active" : "")"
                    @onclick='() => SetFilterCategory("all")'>
                Alla
            </button>
            <button type="button"
                    class="btn btn-outline-success @(filterStateLoaded && filterCategory == "categorized" ? "active" : "")"
                    @onclick='() => SetFilterCategory("categorized")'>
                Kategoriserade
            </button>
            <button type="button"
                    class="btn btn-outline-warning @(filterStateLoaded && filterCategory == "uncategorized" ? "active" : "")"
                    @onclick='() => SetFilterCategory("uncategorized")'>
                Ej kategoriserade
            </button>
        </div>
    </div>
    <div class="ms-auto d-flex gap-2 align-items-center">
        <span class="badge bg-success">Kategoriserade: @CategorizedCount</span>
        <span class="badge bg-warning text-dark">Ej kategoriserade: @UncategorizedCount</span>
        <span class="badge bg-info text-dark">Totalt: @(transactions?.Count ?? 0)</span>
    </div>
</div>

@if (!string.IsNullOrWhiteSpace(errorMessage))
{
    <div class="alert alert-danger" role="alert">@errorMessage</div>
}

@if (!string.IsNullOrWhiteSpace(successMessage))
{
    <div class="alert alert-success" role="alert">@successMessage</div>
}

@if (selectedTransactionIds.Count > 0)
{
    <div class="alert alert-info d-flex flex-column flex-md-row align-items-md-end gap-3" role="alert">
        <div>
            <strong>@selectedTransactionIds.Count</strong> transaktion(er) markerade.
        </div>
        <div class="flex-grow-1">
            <label class="form-label mb-1">Välj kategori</label>
            <select class="form-select form-select-sm"
                    value="@GetSelectedBulkCategoryValue()"
                    @onchange="OnBulkCategoryChanged">
                <option value="">— Välj kategori —</option>
                @foreach (var category in categories)
                {
                    <option value="@category.Id">@GetCategoryDisplayName(category)</option>
                }
            </select>
        </div>
        <div class="d-flex flex-wrap gap-2">
            <button class="btn btn-primary"
                    @onclick="CategorizeSelectedAsync"
                    disabled="@IsBulkActionDisabled">
                @(isBulkCategorizing ? "Kategoriserar..." : $"Kategorisera {selectedTransactionIds.Count}")
            </button>
            <button class="btn btn-link text-decoration-none" type="button" @onclick="ClearSelection">Rensa markering</button>
        </div>
    </div>
}

@if (transactions is null)
{
    <p><em>Laddar...</em></p>
}
else if (FilteredTransactions.Count == 0)
{
    <p>Inga transaktioner hittades.</p>
}
else
{
    <table class="table table-bordered table-striped">
        <thead>
            <tr>
                <th style="width: 48px;">
                    <input type="checkbox"
                           class="form-check-input"
                           @onchange="ToggleSelectAllFiltered"
                           checked="@AreAllFilteredSelected" />
                </th>
                <th>Datum</th>
                <th>Beskrivning</th>
                <th>Belopp</th>
                <th>Saldo</th>
                <th>Type</th>
                <th>Category</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var tx in FilteredTransactions)
            {
                <tr @key="tx.Id">
                    <td class="text-center">
                        <input type="checkbox"
                               class="form-check-input"
                               checked="@IsSelected(tx.Id)"
                               @onchange="e => ToggleSelection(tx.Id, e)" />
                    </td>
                    <td>@tx.TransactionDate.ToShortDateString()</td>
                    <td>@tx.Description</td>
                    <td>@tx.Amount.ToString("F2")</td>
                    <td>@(tx.Balance?.ToString("F2") ?? "-")</td>
                    <td>@(tx.TypeName ?? "—")</td>
                    <td>@(tx.CategoryName ?? "Ej vald")</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private List<TransactionDto>? transactions;
    private List<CategoryDto> categories = new();
    private HashSet<int> selectedTransactionIds = new();
    private int? bulkCategoryId;
    private bool isBulkCategorizing;
    private string? errorMessage;
    private string? successMessage;

    // Filter state
    private string searchText = "";
    private string? filterCategory = null;
    private const string FilterStateKey = "transactions_filter_state";
    private bool filterStateLoaded;

    // Filtrerad lista
    private List<TransactionDto> FilteredTransactions =>
        transactions?
            .Where(tx =>
                (string.IsNullOrWhiteSpace(searchText) || tx.Description.Contains(searchText, StringComparison.OrdinalIgnoreCase)) &&
                ((filterCategory ?? "all") == "all" ||
                 ((filterCategory ?? "all") == "categorized" && tx.CategoryId != null) ||
                 ((filterCategory ?? "all") == "uncategorized" && tx.CategoryId == null))
            )
            .OrderByDescending(t => t.TransactionDate)
            .ToList()
        ?? new();

    // Status info
    private int CategorizedCount => transactions?.Count(tx => tx.CategoryId != null) ?? 0;
    private int UncategorizedCount => transactions?.Count(tx => tx.CategoryId == null) ?? 0;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await LoadFilterStateAsync();

            var client = HttpClientFactory.CreateClient("ApiClient");

            await Task.WhenAll(
                LoadTransactionsAsync(client),
                LoadCategoriesAsync(client)
            );
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Fel vid hämtning: {ex.Message}");
            transactions = new();
            categories = new();
            errorMessage = "Kunde inte läsa in data.";
        }
        finally
        {
            filterStateLoaded = true;
        }
    }

    private string GetCategoryDisplayName(CategoryDto category) =>
        string.IsNullOrWhiteSpace(category.GroupDisplayName)
            ? category.EffectiveName
            : $"{category.GroupDisplayName} / {category.EffectiveName}";

    private string GetSelectedBulkCategoryValue() =>
        bulkCategoryId?.ToString() ?? string.Empty;

    private bool AreAllFilteredSelected
    {
        get
        {
            var filtered = FilteredTransactions;
            if (filtered.Count == 0)
                return false;

            return filtered.All(t => selectedTransactionIds.Contains(t.Id));
        }
    }

    private bool IsSelected(int transactionId) => selectedTransactionIds.Contains(transactionId);

    private void ToggleSelection(int transactionId, ChangeEventArgs e)
    {
        var isChecked = e.Value is bool b && b;
        if (isChecked)
        {
            selectedTransactionIds.Add(transactionId);
        }
        else
        {
            selectedTransactionIds.Remove(transactionId);
        }
    }

    private void ToggleSelectAllFiltered(ChangeEventArgs e)
    {
        var filtered = FilteredTransactions;
        var selectAll = e.Value is bool b && b;

        if (selectAll)
        {
            foreach (var tx in filtered)
                selectedTransactionIds.Add(tx.Id);
        }
        else
        {
            foreach (var tx in filtered)
                selectedTransactionIds.Remove(tx.Id);
        }
    }

    private void OnBulkCategoryChanged(ChangeEventArgs e)
    {
        var rawValue = e.Value?.ToString();
        if (string.IsNullOrWhiteSpace(rawValue))
        {
            bulkCategoryId = null;
            return;
        }

        bulkCategoryId = int.TryParse(rawValue, out var value) ? value : null;
    }

    private bool IsBulkActionDisabled =>
        isBulkCategorizing || bulkCategoryId is null || selectedTransactionIds.Count == 0;

    private void ClearSelection()
    {
        selectedTransactionIds.Clear();
    }

    private async Task CategorizeSelectedAsync()
    {
        if (transactions is null)
            return;

        if (bulkCategoryId is null || selectedTransactionIds.Count == 0)
            return;

        isBulkCategorizing = true;
        successMessage = null;
        errorMessage = null;
        StateHasChanged();

        try
        {
            var client = HttpClientFactory.CreateClient("ApiClient");
            var selected = transactions
                .Where(t => selectedTransactionIds.Contains(t.Id))
                .ToList();

            var manualTargets = selected.Where(t => t.CategoryId == null).ToList();
            var changeTargets = selected.Where(t => t.CategoryId != null).ToList();

            var categorizedCount = 0;
            var updatedCount = 0;
            var autoCategorizedCount = 0;
            var combinedErrors = new List<ManualCategorizeError>();

            // Process uncategorized (manual) grouped by sign to satisfy backend validation
            foreach (var group in manualTargets.GroupBy(t => t.Amount >= 0m))
            {
                var manualRequests = group
                    .Select(t => new CategorizeRequest(t.Id, bulkCategoryId.Value))
                    .ToList();

                var manualResponse = await client.PostAsJsonAsync(
                    "api/transactions/manual-categorize",
                    manualRequests
                );

                if (!manualResponse.IsSuccessStatusCode)
                {
                    var details = await manualResponse.Content.ReadAsStringAsync();
                    errorMessage =
                        $"Kunde inte kategorisera valda transaktioner. ({(int)manualResponse.StatusCode}) {details}";
                    return;
                }

                var manualResult =
                    await manualResponse.Content.ReadFromJsonAsync<ManualCategorizeResponse>()
                    ?? new ManualCategorizeResponse();

                categorizedCount += manualResult.Categorized;
                autoCategorizedCount += manualResult.AutoCategorized;
                combinedErrors.AddRange(manualResult.Errors);

                var manualFailedIds = manualResult.Errors.Select(e => e.TransactionId).ToHashSet();

                foreach (var tx in group)
                {
                    if (manualFailedIds.Contains(tx.Id))
                        continue;

                    tx.CategoryId = bulkCategoryId;
                    UpdateCategoryFields(tx);
                    selectedTransactionIds.Remove(tx.Id);
                }
            }

            // Process already categorized (change) grouped by sign to satisfy backend validation
            foreach (var group in changeTargets.GroupBy(t => t.Amount >= 0m))
            {
                var changeRequests = group
                    .Select(t => new ChangeCategoryRequest(t.Id, bulkCategoryId.Value))
                    .ToList();

                var changeResponse = await client.PostAsJsonAsync(
                    "api/transactions/change-category",
                    changeRequests
                );

                if (!changeResponse.IsSuccessStatusCode)
                {
                    var details = await changeResponse.Content.ReadAsStringAsync();
                    errorMessage =
                        $"Kunde inte uppdatera kategoriserade transaktioner. ({(int)changeResponse.StatusCode}) {details}";
                    return;
                }

                var changeResult =
                    await changeResponse.Content.ReadFromJsonAsync<ChangeCategoryResponse>()
                    ?? new ChangeCategoryResponse();

                updatedCount += changeResult.Updated;
                var changeFailedIds = changeResult.Errors.Select(e => e.TransactionId).ToHashSet();
                var changeErrors = changeResult.Errors
                    .Select(e => new ManualCategorizeError { TransactionId = e.TransactionId, Message = e.Message })
                    .ToList();
                combinedErrors.AddRange(changeErrors);

                foreach (var tx in group)
                {
                    if (changeFailedIds.Contains(tx.Id))
                        continue;

                    tx.CategoryId = bulkCategoryId;
                    UpdateCategoryFields(tx);
                    selectedTransactionIds.Remove(tx.Id);
                }
            }

            var successParts = new List<string>();
            if (categorizedCount > 0)
                successParts.Add($"Kategoriserade {categorizedCount} transaktion(er)");
            if (updatedCount > 0)
                successParts.Add($"Uppdaterade {updatedCount} transaktion(er)");
            if (autoCategorizedCount > 0)
                successParts.Add($"Auto-kategoriserade {autoCategorizedCount} liknande transaktion(er)");

            successMessage = successParts.Count > 0 ? string.Join(". ", successParts) + "." : null;

            var anyChanges = categorizedCount > 0 || updatedCount > 0 || autoCategorizedCount > 0;
            if (anyChanges)
            {
                await RefreshTransactionsAsync();
                selectedTransactionIds.Clear();
            }

            if (combinedErrors.Count > 0)
            {
                var errorList = string.Join(
                    ", ",
                    combinedErrors.Select(e => $"{e.TransactionId}: {e.Message}")
                );
                errorMessage = $"Vissa transaktioner kunde inte hanteras: {errorList}";
            }
        }
        catch (Exception ex)
        {
            errorMessage = ex.Message;
        }
        finally
        {
            isBulkCategorizing = false;
            StateHasChanged();
        }
    }

    private void UpdateCategoryFields(TransactionDto tx)
    {
        var category = tx.CategoryId is int id
            ? categories.FirstOrDefault(c => c.Id == id)
            : null;

        if (category is null)
        {
            tx.CategoryId = null;
            tx.CategoryName = null;
            tx.TypeId = null;
            tx.TypeName = null;
            return;
        }

        tx.CategoryName = category.EffectiveName;
        tx.TypeId = category.GroupId;
        tx.TypeName = category.GroupDisplayName;
    }

    private void SetFilterCategory(string category)
    {
        filterCategory = category;
        _ = SaveFilterStateAsync();
    }

    private async Task OnSearchChanged(ChangeEventArgs e)
    {
        searchText = e.Value?.ToString() ?? "";
        await SaveFilterStateAsync();
    }

    private async Task LoadFilterStateAsync()
    {
        // 1) Läs från in-memory state (Blazor circuit). Ingen async/lagg.
        filterCategory = FilterState.FilterCategory;
        searchText = FilterState.SearchText;

        // 2) Hämta ev. persisted state (för browser refresh). Uppdatera både lokal state och container.
        try
        {
            var result = await BrowserStorage.GetAsync<FilterStatePayload>(FilterStateKey);
            if (result.Success && result.Value is FilterStatePayload state)
            {
                filterCategory = state.FilterCategory ?? filterCategory ?? "all";
                searchText = state.SearchText ?? searchText ?? string.Empty;
                FilterState.FilterCategory = filterCategory ?? "all";
                FilterState.SearchText = searchText ?? string.Empty;
                FilterState.IsLoadedFromStorage = true;
            }
        }
        catch
        {
            // ignore storage errors
        }
    }

    private async Task SaveFilterStateAsync()
    {
        FilterState.FilterCategory = filterCategory ?? "all";
        FilterState.SearchText = searchText ?? string.Empty;

        var state = new FilterStatePayload
        {
            SearchText = FilterState.SearchText,
            FilterCategory = FilterState.FilterCategory,
        };
        try
        {
            await BrowserStorage.SetAsync(FilterStateKey, state);
        }
        catch
        {
            // ignore storage errors
        }
    }

    private async Task LoadTransactionsAsync(HttpClient client)
    {
        var data = await client.GetFromJsonAsync<List<TransactionDto>>("api/transactions");
        transactions = data ?? new();
    }

    private async Task LoadCategoriesAsync(HttpClient client)
    {
        var data = await client.GetFromJsonAsync<List<CategoryGroupDto>>("api/categories");
        categories = data?
            .SelectMany(g => g.Categories)
            .Where(c => c.IsActive && !c.IsHidden)
            .OrderBy(c => c.GroupId)
            .ThenBy(c => c.SortOrder)
            .ToList() ?? new();
    }

    private async Task RefreshTransactionsAsync()
    {
        try
        {
            var client = HttpClientFactory.CreateClient("ApiClient");
            await LoadTransactionsAsync(client);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Fel vid uppdatering: {ex.Message}");
            errorMessage = "Kunde inte uppdatera transaktionerna efter kategorisering.";
        }
    }

    private class FilterStatePayload
    {
        public string? SearchText { get; set; }
        public string? FilterCategory { get; set; }
    }
}
