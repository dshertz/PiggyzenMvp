@page "/transactions"
@rendermode InteractiveServer
@using System.Globalization
@using System.Linq
@using PiggyzenMvp.Blazor.DTOs
@using PiggyzenMvp.Blazor.DTOs.Transactions
@using PiggyzenMvp.Blazor.Services
@inject IHttpClientFactory HttpClientFactory
@inject Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedLocalStorage BrowserStorage
@inject TransactionFilterState FilterState

<TransactionsFilterBar SearchText="@searchText"
                       FilterCategory="@CurrentFilterCategory"
                       FilterSections="@filterSections"
                       OnSearchTextChanged="UpdateSearchTextAsync"
                       OnFilterCategoryChanged="SetFilterCategory"
                       DateFilterMode="@dateFilterMode"
                       IsDateMultiSelect="@isDateMultiSelect"
                       IsDateControlsDisabled="@IsDateControlsDisabled"
                       IsPeriodNavigationDisabled="@IsPeriodNavigationDisabled"
                       CurrentPeriodLabel="@CurrentPeriodLabel"
                       OnDateFilterModeChanged="SetDateFilterMode"
                       OnToggleDateMultiSelect="ToggleDateMultiSelect"
                       OnClearDateFilters="ClearDateFilters"
                       OnStepPeriod="StepPeriod"
                       YearOptions="YearOptionsDisplay"
                       MonthOptions="MonthOptionsDisplay"
                       OnYearSelectionToggled="ToggleYearSelection"
                       OnMonthSelectionToggled="ToggleMonthSelection"
                       YearButtonClassSelector="GetYearButtonClass"
                       MonthButtonClassSelector="GetMonthButtonClass"
                       MonthLabelSelector="GetMonthLabel" />

@if (!string.IsNullOrWhiteSpace(errorMessage))
{
    <div class="alert alert-danger" role="alert">@errorMessage</div>
}

@if (!string.IsNullOrWhiteSpace(successMessage))
{
    <div class="alert alert-success" role="alert">@successMessage</div>
}

@if (selectedTransactionIds.Count > 0)
{
    <div class="alert alert-info d-flex flex-column flex-md-row align-items-md-end gap-3" role="alert">
        <div>
            <strong>@selectedTransactionIds.Count</strong> transaktion(er) markerade.
        </div>
        <div class="flex-grow-1">
            <label class="form-label mb-1">Välj kategori</label>
            <select class="form-select form-select-sm"
                    value="@GetSelectedBulkCategoryValue()"
                    @onchange="OnBulkCategoryChanged">
                <option value="">— Välj kategori —</option>
                @foreach (var category in categories)
                {
                    <option value="@category.Id">@GetCategoryDisplayName(category)</option>
                }
            </select>
        </div>
        <div class="d-flex flex-wrap gap-2">
            <button class="btn btn-primary"
                    @onclick="CategorizeSelectedAsync"
                    disabled="@IsBulkActionDisabled">
                @(isBulkCategorizing ? "Kategoriserar..." : $"Kategorisera {selectedTransactionIds.Count}")
            </button>
            <button class="btn btn-link text-decoration-none" type="button" @onclick="ClearSelection">Rensa markering</button>
        </div>
    </div>
}

@if (transactions is null)
{
    <p><em>Laddar...</em></p>
}
else if (FilteredTransactions.Count == 0)
{
    <p>Inga transaktioner hittades.</p>
}
else
{
    <table class="table table-bordered table-striped">
        <thead>
            <tr>
                <th style="width: 48px;">
                    <input type="checkbox"
                           class="form-check-input"
                           @onchange="ToggleSelectAllFiltered"
                           checked="@AreAllFilteredSelected" />
                </th>
                <th>Datum</th>
                <th>Beskrivning</th>
                <th>Belopp</th>
                <th>Saldo</th>
                <th>Type</th>
                <th>Category</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var tx in FilteredTransactions)
            {
                <tr @key="tx.Id">
                    <td class="text-center">
                        <input type="checkbox"
                               class="form-check-input"
                               checked="@IsSelected(tx.Id)"
                               @onchange="e => ToggleSelection(tx.Id, e)" />
                    </td>
                    <td>@tx.TransactionDate.ToShortDateString()</td>
                    <td>@tx.Description</td>
                    <td>@tx.Amount.ToString("F2")</td>
                    <td>@(tx.Balance?.ToString("F2") ?? "-")</td>
                    <td>@(tx.TypeName ?? "—")</td>
                    <td>@(tx.CategoryName ?? "Ej vald")</td>
                </tr>
            }
        </tbody>
    </table>
}

<div class="transactions-status-bar">
    <span>Kategoriserade: <strong>@CategorizedCount</strong></span>
    <span>Ej kategoriserade: <strong>@UncategorizedCount</strong></span>
    <span>Totalt: <strong>@TotalTransactions</strong></span>
</div>

@code {
    private List<TransactionDto>? transactions;
    private List<CategoryDto> categories = new();
    private List<CategoryGroupDto> categoryGroups = new();
    private HashSet<int> selectedTransactionIds = new();
    private int? bulkCategoryId;
    private bool isBulkCategorizing;
    private string? errorMessage;
    private string? successMessage;

    // Filter state
    private string searchText = "";
    private string filterCategory = "all";
    private const string FilterStateKey = "transactions_filter_state";
    private DateFilterMode dateFilterMode = DateFilterMode.Monthly;
    private bool isDateMultiSelect;
    private HashSet<int> selectedYears = new();
    private HashSet<YearMonth> selectedYearMonths = new();
    private int? activeYear;
    private int? activeMonth;
    private List<int> availableYears = new();
    private List<YearMonth> availableYearMonths = new();
    private static readonly CultureInfo SwedishCulture = CultureInfo.GetCultureInfo("sv-SE");
    private const string CategorizedFilterKey = "categorized";
    private const string UncategorizedFilterKey = "uncategorized";
    private const string PositiveAmountFilterKey = "amount:positive";
    private const string NegativeAmountFilterKey = "amount:negative";
    private const string CategoryFilterPrefix = "category:";
    private const string GroupFilterPrefix = "group:";
    private List<FilterChipSection> filterSections = new()
    {
        new FilterChipSection(null, CreateBaseFilterOptions())
    };
    private List<FilterChipOption> filterOptionOrder = CreateBaseFilterOptions();
    private Dictionary<string, HashSet<int>> groupCategoryMap = new(StringComparer.OrdinalIgnoreCase);
    private string CurrentFilterCategory => filterCategory;
    private int TotalTransactions => transactions?.Count ?? 0;

    // Filtrerad lista
    private List<TransactionDto> FilteredTransactions
    {
        get
        {
            var selectedFilters = ParseFilterSelection(filterCategory);
            var filterCriteria = BuildFilterCriteria(selectedFilters);

            return transactions?
                .Where(tx =>
                    (string.IsNullOrWhiteSpace(searchText) ||
                     tx.Description.Contains(searchText, StringComparison.OrdinalIgnoreCase)) &&
                    MatchesSelectionFilters(tx, filterCriteria) &&
                    MatchesDateFilter(tx))
                .OrderByDescending(t => t.TransactionDate)
                .ToList()
                ?? new();
        }
    }

    // Status info
    private int CategorizedCount => transactions?.Count(tx => tx.CategoryId != null) ?? 0;
    private int UncategorizedCount => transactions?.Count(tx => tx.CategoryId == null) ?? 0;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await LoadFilterStateAsync();

            var client = HttpClientFactory.CreateClient("ApiClient");

            await Task.WhenAll(
                LoadTransactionsAsync(client),
                LoadCategoriesAsync(client)
            );

            BuildFilterSections();
            RefreshAvailablePeriods();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Fel vid hämtning: {ex.Message}");
            transactions = new();
            categories = new();
            errorMessage = "Kunde inte läsa in data.";
        }
    }

    private string GetCategoryDisplayName(CategoryDto category) =>
        string.IsNullOrWhiteSpace(category.GroupDisplayName)
            ? category.EffectiveName
            : $"{category.GroupDisplayName} / {category.EffectiveName}";

    private string GetSelectedBulkCategoryValue() =>
        bulkCategoryId?.ToString() ?? string.Empty;

    private bool AreAllFilteredSelected
    {
        get
        {
            var filtered = FilteredTransactions;
            if (filtered.Count == 0)
                return false;

            return filtered.All(t => selectedTransactionIds.Contains(t.Id));
        }
    }

    private bool IsSelected(int transactionId) => selectedTransactionIds.Contains(transactionId);

    private void ToggleSelection(int transactionId, ChangeEventArgs e)
    {
        var isChecked = e.Value is bool b && b;
        if (isChecked)
        {
            selectedTransactionIds.Add(transactionId);
        }
        else
        {
            selectedTransactionIds.Remove(transactionId);
        }
    }

    private void ToggleSelectAllFiltered(ChangeEventArgs e)
    {
        var filtered = FilteredTransactions;
        var selectAll = e.Value is bool b && b;

        if (selectAll)
        {
            foreach (var tx in filtered)
                selectedTransactionIds.Add(tx.Id);
        }
        else
        {
            foreach (var tx in filtered)
                selectedTransactionIds.Remove(tx.Id);
        }
    }

    private void OnBulkCategoryChanged(ChangeEventArgs e)
    {
        var rawValue = e.Value?.ToString();
        if (string.IsNullOrWhiteSpace(rawValue))
        {
            bulkCategoryId = null;
            return;
        }

        bulkCategoryId = int.TryParse(rawValue, out var value) ? value : null;
    }

    private bool IsBulkActionDisabled =>
        isBulkCategorizing || bulkCategoryId is null || selectedTransactionIds.Count == 0;

    private void ClearSelection()
    {
        selectedTransactionIds.Clear();
    }

    private async Task CategorizeSelectedAsync()
    {
        if (transactions is null)
            return;

        if (bulkCategoryId is null || selectedTransactionIds.Count == 0)
            return;

        isBulkCategorizing = true;
        successMessage = null;
        errorMessage = null;
        StateHasChanged();

        try
        {
            var client = HttpClientFactory.CreateClient("ApiClient");
            var selected = transactions
                .Where(t => selectedTransactionIds.Contains(t.Id))
                .ToList();

            var manualTargets = selected.Where(t => t.CategoryId == null).ToList();
            var changeTargets = selected.Where(t => t.CategoryId != null).ToList();

            var categorizedCount = 0;
            var updatedCount = 0;
            var autoCategorizedCount = 0;
            var combinedErrors = new List<ManualCategorizeError>();

            // Process uncategorized (manual) grouped by sign to satisfy backend validation
            foreach (var group in manualTargets.GroupBy(t => t.Amount >= 0m))
            {
                var manualRequests = group
                    .Select(t => new CategorizeRequest(t.Id, bulkCategoryId.Value))
                    .ToList();

                var manualResponse = await client.PostAsJsonAsync(
                    "api/transactions/manual-categorize",
                    manualRequests
                );

                if (!manualResponse.IsSuccessStatusCode)
                {
                    var details = await manualResponse.Content.ReadAsStringAsync();
                    errorMessage =
                        $"Kunde inte kategorisera valda transaktioner. ({(int)manualResponse.StatusCode}) {details}";
                    return;
                }

                var manualResult =
                    await manualResponse.Content.ReadFromJsonAsync<ManualCategorizeResponse>()
                    ?? new ManualCategorizeResponse();

                categorizedCount += manualResult.Categorized;
                autoCategorizedCount += manualResult.AutoCategorized;
                combinedErrors.AddRange(manualResult.Errors);

                var manualFailedIds = manualResult.Errors.Select(e => e.TransactionId).ToHashSet();

                foreach (var tx in group)
                {
                    if (manualFailedIds.Contains(tx.Id))
                        continue;

                    tx.CategoryId = bulkCategoryId;
                    UpdateCategoryFields(tx);
                    selectedTransactionIds.Remove(tx.Id);
                }
            }

            // Process already categorized (change) grouped by sign to satisfy backend validation
            foreach (var group in changeTargets.GroupBy(t => t.Amount >= 0m))
            {
                var changeRequests = group
                    .Select(t => new ChangeCategoryRequest(t.Id, bulkCategoryId.Value))
                    .ToList();

                var changeResponse = await client.PostAsJsonAsync(
                    "api/transactions/change-category",
                    changeRequests
                );

                if (!changeResponse.IsSuccessStatusCode)
                {
                    var details = await changeResponse.Content.ReadAsStringAsync();
                    errorMessage =
                        $"Kunde inte uppdatera kategoriserade transaktioner. ({(int)changeResponse.StatusCode}) {details}";
                    return;
                }

                var changeResult =
                    await changeResponse.Content.ReadFromJsonAsync<ChangeCategoryResponse>()
                    ?? new ChangeCategoryResponse();

                updatedCount += changeResult.Updated;
                var changeFailedIds = changeResult.Errors.Select(e => e.TransactionId).ToHashSet();
                var changeErrors = changeResult.Errors
                    .Select(e => new ManualCategorizeError { TransactionId = e.TransactionId, Message = e.Message })
                    .ToList();
                combinedErrors.AddRange(changeErrors);

                foreach (var tx in group)
                {
                    if (changeFailedIds.Contains(tx.Id))
                        continue;

                    tx.CategoryId = bulkCategoryId;
                    UpdateCategoryFields(tx);
                    selectedTransactionIds.Remove(tx.Id);
                }
            }

            var successParts = new List<string>();
            if (categorizedCount > 0)
                successParts.Add($"Kategoriserade {categorizedCount} transaktion(er)");
            if (updatedCount > 0)
                successParts.Add($"Uppdaterade {updatedCount} transaktion(er)");
            if (autoCategorizedCount > 0)
                successParts.Add($"Auto-kategoriserade {autoCategorizedCount} liknande transaktion(er)");

            successMessage = successParts.Count > 0 ? string.Join(". ", successParts) + "." : null;

            var anyChanges = categorizedCount > 0 || updatedCount > 0 || autoCategorizedCount > 0;
            if (anyChanges)
            {
                await RefreshTransactionsAsync();
                selectedTransactionIds.Clear();
            }

            if (combinedErrors.Count > 0)
            {
                var errorList = string.Join(
                    ", ",
                    combinedErrors.Select(e => $"{e.TransactionId}: {e.Message}")
                );
                errorMessage = $"Vissa transaktioner kunde inte hanteras: {errorList}";
            }
        }
        catch (Exception ex)
        {
            errorMessage = ex.Message;
        }
        finally
        {
            isBulkCategorizing = false;
            StateHasChanged();
        }
    }

    private void UpdateCategoryFields(TransactionDto tx)
    {
        var category = tx.CategoryId is int id
            ? categories.FirstOrDefault(c => c.Id == id)
            : null;

        if (category is null)
        {
            tx.CategoryId = null;
            tx.CategoryName = null;
            tx.TypeId = null;
            tx.TypeName = null;
            return;
        }

        tx.CategoryName = category.EffectiveName;
        tx.TypeId = category.GroupId;
        tx.TypeName = category.GroupDisplayName;
    }

    private IEnumerable<int> YearOptionsDisplay => availableYears.OrderByDescending(y => y);
    private IEnumerable<YearMonth> MonthOptionsDisplay =>
        availableYearMonths.OrderByDescending(p => p.Year).ThenByDescending(p => p.Month);
    private bool HasPeriodData => availableYearMonths.Count > 0;
    private bool HasActiveSinglePeriod =>
        dateFilterMode == DateFilterMode.Yearly
            ? activeYear.HasValue
            : dateFilterMode == DateFilterMode.Monthly
                ? activeYear.HasValue && activeMonth.HasValue
                : true;
    private bool IsDateControlsDisabled => dateFilterMode == DateFilterMode.All || !HasPeriodData;
    private bool IsPeriodNavigationDisabled =>
        dateFilterMode == DateFilterMode.All || isDateMultiSelect || !HasActiveSinglePeriod;
    private string CurrentPeriodLabel => dateFilterMode switch
    {
        DateFilterMode.All => "Alla datum",
        DateFilterMode.Yearly => activeYear?.ToString() ?? "Välj år",
        DateFilterMode.Monthly => activeYear.HasValue && activeMonth.HasValue
            ? new DateTime(activeYear.Value, activeMonth.Value, 1).ToString("MMMM yyyy", SwedishCulture)
            : "Välj månad",
        _ => "Alla datum"
    };

    private void SetDateFilterMode(DateFilterMode mode)
    {
        if (dateFilterMode == mode)
            return;

        dateFilterMode = mode;
        if (mode == DateFilterMode.All)
        {
            isDateMultiSelect = false;
        }
        else if (mode == DateFilterMode.Yearly)
        {
            activeMonth = null;
        }

        EnsurePeriodSelectionIsValid();
        _ = SaveFilterStateAsync();
    }

    private void ToggleDateMultiSelect()
    {
        if (IsDateControlsDisabled)
            return;

        isDateMultiSelect = !isDateMultiSelect;
        if (isDateMultiSelect)
        {
            SeedMultiSelectionFromActive();
        }
        else
        {
            if (dateFilterMode == DateFilterMode.Yearly)
            {
                if (selectedYears.Count > 0)
                {
                    activeYear = selectedYears.OrderByDescending(y => y).First();
                }
                selectedYears.Clear();
            }
            else if (dateFilterMode == DateFilterMode.Monthly)
            {
                if (selectedYearMonths.Count > 0)
                {
                    var latest = selectedYearMonths
                        .OrderBy(p => p.Year)
                        .ThenBy(p => p.Month)
                        .Last();
                    activeYear = latest.Year;
                    activeMonth = latest.Month;
                }
                selectedYearMonths.Clear();
            }
        }

        _ = SaveFilterStateAsync();
    }

    private void ToggleYearSelection(int year)
    {
        if (dateFilterMode != DateFilterMode.Yearly || !availableYears.Contains(year))
            return;

        if (isDateMultiSelect)
        {
            if (!selectedYears.Add(year))
                selectedYears.Remove(year);
        }
        else
        {
            activeYear = year;
        }

        _ = SaveFilterStateAsync();
    }

    private void ToggleMonthSelection(YearMonth option)
    {
        if (dateFilterMode != DateFilterMode.Monthly || !availableYearMonths.Contains(option))
            return;

        if (isDateMultiSelect)
        {
            if (!selectedYearMonths.Add(option))
                selectedYearMonths.Remove(option);
        }
        else
        {
            activeYear = option.Year;
            activeMonth = option.Month;
        }

        _ = SaveFilterStateAsync();
    }

    private void StepPeriod(int direction)
    {
        if (IsPeriodNavigationDisabled)
            return;

        if (dateFilterMode == DateFilterMode.Yearly && activeYear.HasValue)
        {
            var currentIndex = availableYears.IndexOf(activeYear.Value);
            var nextIndex = currentIndex + direction;
            if (nextIndex >= 0 && nextIndex < availableYears.Count)
            {
                activeYear = availableYears[nextIndex];
            }
        }
        else if (dateFilterMode == DateFilterMode.Monthly && activeYear.HasValue && activeMonth.HasValue)
        {
            var current = new YearMonth(activeYear.Value, activeMonth.Value);
            var currentIndex = availableYearMonths.IndexOf(current);
            var nextIndex = currentIndex + direction;
            if (nextIndex >= 0 && nextIndex < availableYearMonths.Count)
            {
                var target = availableYearMonths[nextIndex];
                activeYear = target.Year;
                activeMonth = target.Month;
            }
        }

        _ = SaveFilterStateAsync();
    }

    private void ClearDateFilters()
    {
        if (!HasPeriodData)
            return;

        dateFilterMode = DateFilterMode.Monthly;
        isDateMultiSelect = false;
        var latest = availableYearMonths.Last();
        activeYear = latest.Year;
        activeMonth = latest.Month;
        selectedYears.Clear();
        selectedYearMonths.Clear();
        EnsurePeriodSelectionIsValid();

        _ = SaveFilterStateAsync();
    }

    private string GetYearButtonClass(int year)
    {
        var isActive = isDateMultiSelect ? selectedYears.Contains(year) : activeYear == year;
        return GetChipClass(isActive);
    }

    private string GetMonthButtonClass(YearMonth option)
    {
        var isActive = isDateMultiSelect
            ? selectedYearMonths.Contains(option)
            : activeYear == option.Year && activeMonth == option.Month;
        return GetChipClass(isActive);
    }

    private static string GetChipClass(bool isActive) =>
        isActive ? "btn btn-sm btn-primary" : "btn btn-sm btn-outline-secondary";

    private static string GetMonthLabel(YearMonth option)
    {
        var date = new DateTime(option.Year, option.Month, 1);
        var monthAbbreviation = date.ToString("MMM", SwedishCulture).TrimEnd('.');
        return monthAbbreviation.ToLower(SwedishCulture);
    }

    private void RefreshAvailablePeriods()
    {
        if (transactions is null || transactions.Count == 0)
        {
            availableYears = new();
            availableYearMonths = new();
            activeYear = null;
            activeMonth = null;
            selectedYears.Clear();
            selectedYearMonths.Clear();
            dateFilterMode = DateFilterMode.All;
            isDateMultiSelect = false;
            return;
        }

        availableYears = transactions
            .Select(t => t.TransactionDate.Year)
            .Distinct()
            .OrderBy(y => y)
            .ToList();

        availableYearMonths = transactions
            .Select(t => new YearMonth(t.TransactionDate.Year, t.TransactionDate.Month))
            .Distinct()
            .OrderBy(p => p.Year)
            .ThenBy(p => p.Month)
            .ToList();

        EnsurePeriodSelectionIsValid();
    }

    private void EnsurePeriodSelectionIsValid()
    {
        if (!HasPeriodData)
            return;

        var latest = availableYearMonths.Last();

        if (!activeYear.HasValue || !availableYears.Contains(activeYear.Value))
        {
            activeYear = latest.Year;
        }

        if (dateFilterMode == DateFilterMode.Monthly)
        {
            var desired = activeYear.HasValue && activeMonth.HasValue
                ? new YearMonth(activeYear.Value, activeMonth.Value)
                : latest;

            if (!availableYearMonths.Contains(desired))
            {
                var fallbacks = availableYearMonths.Where(p => p.Year == activeYear).ToList();
                if (fallbacks.Count > 0)
                {
                    desired = fallbacks.Last();
                }
                else
                {
                    desired = latest;
                }
            }

            activeYear = desired.Year;
            activeMonth = desired.Month;
        }
        else if (dateFilterMode == DateFilterMode.Yearly)
        {
            activeMonth = null;
        }

        selectedYears.RemoveWhere(year => !availableYears.Contains(year));
        selectedYearMonths.RemoveWhere(period => !availableYearMonths.Contains(period));

        if (isDateMultiSelect)
        {
            if (dateFilterMode == DateFilterMode.Yearly && selectedYears.Count == 0 && activeYear.HasValue)
            {
                selectedYears.Add(activeYear.Value);
            }
            else if (dateFilterMode == DateFilterMode.Monthly &&
                     selectedYearMonths.Count == 0 &&
                     activeYear.HasValue &&
                     activeMonth.HasValue)
            {
                selectedYearMonths.Add(new YearMonth(activeYear.Value, activeMonth.Value));
            }
        }
    }

    private void SeedMultiSelectionFromActive()
    {
        if (dateFilterMode == DateFilterMode.Yearly && activeYear.HasValue)
        {
            selectedYears.Add(activeYear.Value);
        }
        else if (dateFilterMode == DateFilterMode.Monthly && activeYear.HasValue && activeMonth.HasValue)
        {
            selectedYearMonths.Add(new YearMonth(activeYear.Value, activeMonth.Value));
        }
    }

    private static HashSet<string> ParseFilterSelection(string? value)
    {
        var set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        if (string.IsNullOrWhiteSpace(value) || value.Equals("all", StringComparison.OrdinalIgnoreCase))
        {
            return set;
        }

        var parts = value.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        foreach (var part in parts)
        {
            set.Add(part);
        }

        return set;
    }

    private string NormalizeFilterCategory(string? value, bool dropUnknown = false)
    {
        var parsed = ParseFilterSelection(value);
        if (parsed.Count == 0)
        {
            return "all";
        }

        var orderedKeys = filterOptionOrder.Select(o => o.Key).Where(parsed.Contains).ToList();
        var seen = new HashSet<string>(orderedKeys, StringComparer.OrdinalIgnoreCase);
        var extras = parsed
            .Where(k => !seen.Contains(k))
            .OrderBy(k => k, StringComparer.OrdinalIgnoreCase);

        return dropUnknown
            ? string.Join(',', orderedKeys)
            : string.Join(',', orderedKeys.Concat(extras));
    }

    private bool MatchesDateFilter(TransactionDto tx)
    {
        if (dateFilterMode == DateFilterMode.All)
            return true;

        var year = tx.TransactionDate.Year;
        if (dateFilterMode == DateFilterMode.Yearly)
        {
            if (isDateMultiSelect)
            {
                return selectedYears.Count == 0 || selectedYears.Contains(year);
            }

            return !activeYear.HasValue || year == activeYear.Value;
        }

        var month = tx.TransactionDate.Month;
        if (isDateMultiSelect)
        {
            return selectedYearMonths.Count == 0 || selectedYearMonths.Contains(new YearMonth(year, month));
        }

        if (!activeYear.HasValue || !activeMonth.HasValue)
            return true;

        return year == activeYear.Value && month == activeMonth.Value;
    }

    private static bool MatchesSelectionFilters(TransactionDto tx, FilterCriteria criteria)
    {
        var statusMatch = !criteria.HasStatusFilters ||
            ((criteria.IncludeCategorized && tx.CategoryId != null) ||
             (criteria.IncludeUncategorized && tx.CategoryId == null));
        var amountMatch = !criteria.HasAmountFilters ||
            ((criteria.IncludePositive && tx.Amount >= 0) ||
             (criteria.IncludeNegative && tx.Amount < 0));
        var categoryMatch = criteria.CategoryIds.Count == 0 ||
            (tx.CategoryId is int id && criteria.CategoryIds.Contains(id));

        return statusMatch && amountMatch && categoryMatch;
    }

    private FilterCriteria BuildFilterCriteria(HashSet<string> filters)
    {
        var includeCategorized = filters.Contains(CategorizedFilterKey);
        var includeUncategorized = filters.Contains(UncategorizedFilterKey);
        var includePositive = filters.Contains(PositiveAmountFilterKey);
        var includeNegative = filters.Contains(NegativeAmountFilterKey);

        var categoryIds = new HashSet<int>();
        foreach (var key in filters)
        {
            if (key.StartsWith(CategoryFilterPrefix, StringComparison.OrdinalIgnoreCase))
            {
                var raw = key.Substring(CategoryFilterPrefix.Length);
                if (int.TryParse(raw, out var parsed))
                {
                    categoryIds.Add(parsed);
                }
            }
            else if (key.StartsWith(GroupFilterPrefix, StringComparison.OrdinalIgnoreCase) &&
                     groupCategoryMap.TryGetValue(key, out var ids))
            {
                foreach (var id in ids)
                {
                    categoryIds.Add(id);
                }
            }
        }

        return new FilterCriteria(includeCategorized, includeUncategorized, includePositive, includeNegative, categoryIds);
    }

    private void SetFilterCategory(string category)
    {
        filterCategory = NormalizeFilterCategory(category);
        _ = SaveFilterStateAsync();
    }

    private async Task UpdateSearchTextAsync(string? value)
    {
        searchText = value ?? string.Empty;
        await SaveFilterStateAsync();
    }

    private async Task LoadFilterStateAsync()
    {
        // 1) Läs från in-memory state (Blazor circuit). Ingen async/lagg.
        filterCategory = NormalizeFilterCategory(FilterState.FilterCategory);
        FilterState.FilterCategory = filterCategory;
        searchText = FilterState.SearchText;
        dateFilterMode = FilterState.DateMode;
        isDateMultiSelect = FilterState.IsDateMultiSelect;
        activeYear = FilterState.ActiveYear;
        activeMonth = FilterState.ActiveMonth;
        selectedYears = new HashSet<int>(FilterState.SelectedYears ?? new List<int>());
        selectedYearMonths = FilterState.SelectedYearMonths?
            .Select(value => YearMonth.TryParse(value, out var period) ? period : (YearMonth?)null)
            .Where(p => p.HasValue)
            .Select(p => p.Value)
            .ToHashSet() ?? new HashSet<YearMonth>();

        // 2) Hämta ev. persisted state (för browser refresh). Uppdatera både lokal state och container.
        try
        {
            var result = await BrowserStorage.GetAsync<FilterStatePayload>(FilterStateKey);
            if (result.Success && result.Value is FilterStatePayload state)
            {
                filterCategory = NormalizeFilterCategory(state.FilterCategory ?? filterCategory ?? "all");
                searchText = state.SearchText ?? searchText ?? string.Empty;
                dateFilterMode = state.DateMode;
                isDateMultiSelect = state.IsDateMultiSelect;
                activeYear = state.ActiveYear;
                activeMonth = state.ActiveMonth;
                selectedYears = state.SelectedYears?.ToHashSet() ?? selectedYears;
                selectedYearMonths = state.SelectedYearMonths?
                    .Select(value => YearMonth.TryParse(value, out var period) ? period : (YearMonth?)null)
                    .Where(p => p.HasValue)
                    .Select(p => p.Value)
                    .ToHashSet() ?? selectedYearMonths;
                FilterState.FilterCategory = filterCategory;
                FilterState.SearchText = searchText ?? string.Empty;
                FilterState.DateMode = dateFilterMode;
                FilterState.IsDateMultiSelect = isDateMultiSelect;
                FilterState.ActiveYear = activeYear;
                FilterState.ActiveMonth = activeMonth;
                FilterState.SelectedYears = selectedYears.ToList();
                FilterState.SelectedYearMonths = selectedYearMonths.Select(p => p.ToStorageKey()).ToList();
                FilterState.IsLoadedFromStorage = true;
            }
        }
        catch
        {
            // ignore storage errors
        }
    }

    private async Task SaveFilterStateAsync()
    {
        FilterState.FilterCategory = filterCategory;
        FilterState.SearchText = searchText ?? string.Empty;
        FilterState.DateMode = dateFilterMode;
        FilterState.IsDateMultiSelect = isDateMultiSelect;
        FilterState.ActiveYear = activeYear;
        FilterState.ActiveMonth = activeMonth;
        FilterState.SelectedYears = selectedYears.ToList();
        FilterState.SelectedYearMonths = selectedYearMonths.Select(p => p.ToStorageKey()).ToList();

        var state = new FilterStatePayload
        {
            SearchText = FilterState.SearchText,
            FilterCategory = FilterState.FilterCategory,
            DateMode = FilterState.DateMode,
            IsDateMultiSelect = FilterState.IsDateMultiSelect,
            ActiveYear = FilterState.ActiveYear,
            ActiveMonth = FilterState.ActiveMonth,
            SelectedYears = FilterState.SelectedYears,
            SelectedYearMonths = FilterState.SelectedYearMonths,
        };
        try
        {
            await BrowserStorage.SetAsync(FilterStateKey, state);
        }
        catch
        {
            // ignore storage errors
        }
    }

    private async Task LoadTransactionsAsync(HttpClient client)
    {
        var data = await client.GetFromJsonAsync<List<TransactionDto>>("api/transactions");
        transactions = data ?? new();
    }

    private async Task LoadCategoriesAsync(HttpClient client)
    {
        var data = await client.GetFromJsonAsync<List<CategoryGroupDto>>("api/categories") ?? new();

        categoryGroups = data
            .Select(g => new CategoryGroupDto
            {
                Id = g.Id,
                Key = g.Key,
                DisplayName = g.DisplayName,
                SortOrder = g.SortOrder,
                Categories = g.Categories
                    .Where(c => c.IsActive && !c.IsHidden)
                    .OrderBy(c => c.SortOrder)
                    .ToList()
            })
            .Where(g => g.Categories.Count > 0)
            .OrderBy(g => g.SortOrder)
            .ThenBy(g => g.DisplayName)
            .ToList();

        categories = categoryGroups
            .SelectMany(g => g.Categories)
            .OrderBy(c => c.GroupId)
            .ThenBy(c => c.SortOrder)
            .ToList();
    }

    private async Task RefreshTransactionsAsync()
    {
        try
        {
            var client = HttpClientFactory.CreateClient("ApiClient");
            await LoadTransactionsAsync(client);
            RefreshAvailablePeriods();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Fel vid uppdatering: {ex.Message}");
            errorMessage = "Kunde inte uppdatera transaktionerna efter kategorisering.";
        }
    }
    
    private static List<FilterChipOption> CreateBaseFilterOptions() => new()
    {
        new FilterChipOption(CategorizedFilterKey, "Kategoriserade"),
        new FilterChipOption(UncategorizedFilterKey, "Ej kategoriserade"),
        new FilterChipOption(PositiveAmountFilterKey, "Positiva belopp"),
        new FilterChipOption(NegativeAmountFilterKey, "Negativa belopp")
    };

    private void BuildFilterSections()
    {
        groupCategoryMap = new Dictionary<string, HashSet<int>>(StringComparer.OrdinalIgnoreCase);

        var sections = new List<FilterChipSection>();
        var baseSectionOptions = CreateBaseFilterOptions();
        sections.Add(new FilterChipSection(null, baseSectionOptions));

        foreach (var group in categoryGroups)
        {
            var groupLabel = string.IsNullOrWhiteSpace(group.DisplayName) ? "Övrigt" : group.DisplayName;
            var groupKey = $"{GroupFilterPrefix}{group.Id}";

            var sectionOptions = new List<FilterChipOption>
            {
                new FilterChipOption(groupKey, groupLabel, null, true)
            };

            foreach (var category in group.Categories)
            {
                sectionOptions.Add(new FilterChipOption($"{CategoryFilterPrefix}{category.Id}", category.EffectiveName, groupKey));
            }

            groupCategoryMap[groupKey] = group.Categories.Select(c => c.Id).ToHashSet();
            sections.Add(new FilterChipSection(null, sectionOptions));
        }

        filterSections = sections;
        filterOptionOrder = sections.SelectMany(s => s.Options).ToList();
        filterCategory = NormalizeFilterCategory(filterCategory, dropUnknown: true);
        FilterState.FilterCategory = filterCategory;
    }

    private sealed record FilterCriteria(
        bool IncludeCategorized,
        bool IncludeUncategorized,
        bool IncludePositive,
        bool IncludeNegative,
        HashSet<int> CategoryIds)
    {
        public bool HasStatusFilters => IncludeCategorized || IncludeUncategorized;
        public bool HasAmountFilters => IncludePositive || IncludeNegative;
        public bool HasCategoryFilters => CategoryIds.Count > 0;
    }

    private class FilterStatePayload
    {
        public string? SearchText { get; set; }
        public string? FilterCategory { get; set; }
        public DateFilterMode DateMode { get; set; } = DateFilterMode.Monthly;
        public bool IsDateMultiSelect { get; set; }
        public int? ActiveYear { get; set; }
        public int? ActiveMonth { get; set; }
        public List<int>? SelectedYears { get; set; }
        public List<string>? SelectedYearMonths { get; set; }
    }
}
