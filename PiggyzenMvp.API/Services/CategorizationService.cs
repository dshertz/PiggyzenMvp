using Microsoft.EntityFrameworkCore;
using PiggyzenMvp.API.Data;
using PiggyzenMvp.API.DTOs.Transactions;
using PiggyzenMvp.API.Models;

namespace PiggyzenMvp.API.Services
{
    public record AutoCategorizeResult(int TransactionId, string? Error);

    public record ManualCategorizationResult(string? Error, int AutoCategorized);

    public enum SignRule
    {
        MustBePositive,
        MustBeNegative,
        CanBeEither,
    }

    public class CategorizationService
    {
        private readonly PiggyzenMvpContext _context;
        private readonly NormalizeService _normalize;

        public CategorizationService(PiggyzenMvpContext context, NormalizeService normalize)
        {
            _context = context;
            _normalize = normalize;
        }

        /// <summary>
        /// Manuell kategorisering av en transaktion (admin/UX-val).
        /// - Skapar eller uppdaterar en historikrad kopplad till manuellt val.
        /// - Säkerställer att Transaktionen och dess Usage pekar på den manuella regeln.
        /// </summary>
        public async Task<ManualCategorizationResult> CategorizeManuallyAsync(
            int transactionId,
            int categoryId,
            CancellationToken ct = default
        )
        {
            var t = await _context
                .Transactions.Include(x => x.CategorizationUsage)
                .ThenInclude(u => u.CategorizationRule)
                .FirstOrDefaultAsync(x => x.Id == transactionId, ct);

            if (t == null)
                return new ManualCategorizationResult("Transaction not found.", 0);

            if (t.CategoryId != null)
                return new ManualCategorizationResult("Transaction is already categorized.", 0);

            var category = await _context
                .Categories.Include(c => c.Group)
                .FirstOrDefaultAsync(c => c.Id == categoryId, ct);
            if (category == null)
                return new ManualCategorizationResult("Category not found.", 0);

            var signError = ValidateAmountSign(t.Amount, category);
            if (signError != null)
                return new ManualCategorizationResult(signError, 0);

            var norm = t.NormalizedDescription;
            var isPos = t.Amount >= 0m;

            var candidateRules = await _context
                .CategorizationRules.Where(r =>
                    r.NormalizedDescription == norm && r.CategoryId == categoryId
                )
                .ToListAsync(ct);

            var history =
                candidateRules.FirstOrDefault(r => r.IsPositive == isPos)
                ?? candidateRules.FirstOrDefault(r => r.IsPositive == null);

            if (history == null)
            {
                var now = DateTime.UtcNow;
                history = new CategorizationRule
                {
                    Description = t.Description,
                    NormalizedDescription = norm,
                    IsDescriptionAutoGenerated = IsDescriptionAutoGenerated(t.Description),
                    IsPositive = isPos,
                    CategoryId = categoryId,
                    IsRefund = null,
                    Created = now,
                    UsageCount = 0,
                    LastUsedAt = null,
                };
                await _context.CategorizationRules.AddAsync(history, ct);
            }

            var nowTime = DateTime.UtcNow;

            if (t.CategorizationUsage != null)
                return new ManualCategorizationResult(
                    "Internal error: Usage exists but transaction is uncategorized.",
                    0
                );

            var usage = new CategorizationUsage
            {
                TransactionId = t.Id,
                Amount = t.Amount,
                TransactionDate = t.TransactionDate,
                CategorizationRule = history,
                UsedAt = nowTime,
                WasOverridden = null,
                Source = CategorizationSource.Manual,
            };
            _context.CategorizationUsages.Add(usage);

            // Håll Transaction i synk för snabba queries
            t.CategoryId = categoryId;

            history.UsageCount += 1;
            history.LastUsedAt = nowTime;

            await _context.SaveChangesAsync(ct);
            var autoCategorized = await AutoCategorizeSimilarTransactionsAsync(t, history, ct);
            return new ManualCategorizationResult(null, autoCategorized);
        }

        public async Task<string?> ChangeCategoryAsync(
            int transactionId,
            int newCategoryId,
            CancellationToken ct = default
        )
        {
            var tx = await _context
                .Transactions.Include(t => t.CategorizationUsage)
                .ThenInclude(u => u.CategorizationRule)
                .FirstOrDefaultAsync(t => t.Id == transactionId, ct);

            if (tx == null)
                return "Transaction not found.";

            if (tx.CategoryId == null)
                return "Transaction is not categorized yet.";

            if (tx.CategoryId == newCategoryId)
                return null;

            var newCategory = await _context
                .Categories.Include(c => c.Group)
                .FirstOrDefaultAsync(c => c.Id == newCategoryId, ct);
            if (newCategory == null)
                return "Category not found.";

            var signError = ValidateAmountSign(tx.Amount, newCategory);
            if (signError != null)
                return signError;

            var usage = tx.CategorizationUsage;
            if (usage == null)
                return "Internal error: transaction has no CategorizationUsage.";

            var oldRule = usage.CategorizationRule;
            if (oldRule == null)
                return "Internal error: transaction usage is missing CategorizationRule.";

            var normalized = tx.NormalizedDescription;
            var isPositive = tx.Amount >= 0m;

            var candidateRules = await _context
                .CategorizationRules.Where(r =>
                    r.NormalizedDescription == normalized && r.CategoryId == newCategoryId
                )
                .ToListAsync(ct);

            var matchedRule =
                candidateRules.FirstOrDefault(r => r.IsPositive == isPositive)
                ?? candidateRules.FirstOrDefault(r => r.IsPositive == null);

            var now = DateTime.UtcNow;

            if (matchedRule == null)
            {
                matchedRule = new CategorizationRule
                {
                    Description = tx.Description,
                    NormalizedDescription = normalized,
                    IsDescriptionAutoGenerated = IsDescriptionAutoGenerated(tx.Description),
                    IsPositive = isPositive,
                    CategoryId = newCategoryId,
                    IsRefund = null,
                    Created = now,
                    UsageCount = 0,
                    LastUsedAt = null,
                };

                await _context.CategorizationRules.AddAsync(matchedRule, ct);
            }

            usage.WasOverridden = now;
            usage.CategorizationRule = matchedRule;
            usage.UsedAt = now;
            usage.Source = CategorizationSource.Manual;

            tx.CategoryId = newCategoryId;

            if (oldRule.UsageCount > 0)
                oldRule.UsageCount -= 1;

            matchedRule.UsageCount += 1;
            matchedRule.LastUsedAt = now;

            var latestRemainingUsage = await _context
                .CategorizationUsages.Where(u =>
                    u.CategorizationRuleId == oldRule.Id && u.Id != usage.Id
                )
                .OrderByDescending(u => u.UsedAt)
                .Select(u => (DateTime?)u.UsedAt)
                .FirstOrDefaultAsync(ct);

            oldRule.LastUsedAt = latestRemainingUsage;

            await _context.SaveChangesAsync(ct);
            await CleanupOrphanedRulesAsync(new[] { oldRule.Id }, ct);
            return null;
        }

        public async Task<List<SimilarTransactionDto>?> GetSimilarUncategorizedAsync(
            int transactionId,
            CancellationToken ct = default
        )
        {
            var tx = await _context
                .Transactions.AsNoTracking()
                .FirstOrDefaultAsync(t => t.Id == transactionId, ct);

            if (tx == null)
                return null;

            var normalized = tx.NormalizedDescription;
            var isPositive = tx.Amount >= 0m;

            var similar = await _context
                .Transactions.AsNoTracking()
                .Where(t =>
                    t.CategoryId == null
                    && t.NormalizedDescription == normalized
                    && (t.Amount >= 0m) == isPositive
                    && t.Id != transactionId
                )
                .OrderByDescending(t => t.TransactionDate)
                .Select(t => new SimilarTransactionDto(
                    t.Id,
                    t.TransactionDate,
                    t.Description,
                    t.Amount
                ))
                .ToListAsync(ct);

            return similar;
        }

        public async Task<IReadOnlyCollection<AutoCategorizeResult>> AutoCategorizeBatchAsync(
            IReadOnlyCollection<int> transactionIds,
            CancellationToken ct = default
        )
        {
            if (transactionIds == null || transactionIds.Count == 0)
                return Array.Empty<AutoCategorizeResult>();

            var distinctIds = transactionIds.Distinct().ToList();
            var results = new List<AutoCategorizeResult>(distinctIds.Count);

            foreach (var id in distinctIds)
            {
                var error = await AutoCategorizeSingleAsync(id, ct);
                results.Add(new AutoCategorizeResult(id, error));
            }

            return results;
        }

        private async Task<string?> AutoCategorizeSingleAsync(
            int transactionId,
            CancellationToken ct
        )
        {
            var tx = await _context
                .Transactions.Include(t => t.CategorizationUsage)
                .ThenInclude(u => u.CategorizationRule)
                .FirstOrDefaultAsync(t => t.Id == transactionId, ct);

            if (tx == null)
                return "Transaction not found.";

            if (tx.CategoryId != null)
                return "Transaction is already categorized.";

            var normalized = tx.NormalizedDescription;
            var isPositive = tx.Amount >= 0m;

            var rules = await _context
                .CategorizationRules.Where(r => r.NormalizedDescription == normalized)
                .ToListAsync(ct);

            if (rules.Count == 0)
                return "No matching rules.";

            var autoRules = rules.Where(r => r.IsDescriptionAutoGenerated).ToList();
            if (autoRules.Count == 0)
                return "No auto-generated rules for this merchant.";

            var validRules = autoRules
                .Where(r => r.IsPositive == null || r.IsPositive == isPositive)
                .ToList();

            if (validRules.Count == 0)
                return "No rules matching sign.";

            CategorizationRule bestRule;
            if (validRules.Count == 1)
                bestRule = validRules[0];
            else
                bestRule = validRules.OrderByDescending(r => r.UsageCount).First();

            var now = DateTime.UtcNow;

            if (tx.CategorizationUsage == null)
            {
                var usage = new CategorizationUsage
                {
                    TransactionId = tx.Id,
                    Amount = tx.Amount,
                    TransactionDate = tx.TransactionDate,
                    CategorizationRule = bestRule,
                    UsedAt = now,
                    Source = CategorizationSource.Auto,
                };

                await _context.CategorizationUsages.AddAsync(usage, ct);
            }
            else
            {
                tx.CategorizationUsage.CategorizationRule = bestRule;
                tx.CategorizationUsage.UsedAt = now;
                tx.CategorizationUsage.Source = CategorizationSource.Auto;
                tx.CategorizationUsage.WasOverridden = null;
            }

            tx.CategoryId = bestRule.CategoryId;

            bestRule.UsageCount += 1;
            bestRule.LastUsedAt = now;

            await _context.SaveChangesAsync(ct);
            return null;
        }

        private async Task<int> AutoCategorizeSimilarTransactionsAsync(
            Transaction referenceTransaction,
            CategorizationRule rule,
            CancellationToken ct
        )
        {
            if (!rule.IsDescriptionAutoGenerated)
                return 0;

            var normalized = referenceTransaction.NormalizedDescription;
            var isPositive = referenceTransaction.Amount >= 0m;

            var similarTransactions = await _context
                .Transactions.Include(t => t.CategorizationUsage)
                .Where(t =>
                    t.CategoryId == null
                    && t.NormalizedDescription == normalized
                    && (t.Amount >= 0m) == isPositive
                    && t.Id != referenceTransaction.Id
                )
                .ToListAsync(ct);

            if (similarTransactions.Count == 0)
                return 0;

            var autoCategorized = 0;
            var now = DateTime.UtcNow;

            foreach (var tx in similarTransactions)
            {
                if (tx.CategorizationUsage != null)
                    continue;

                var usage = new CategorizationUsage
                {
                    TransactionId = tx.Id,
                    Amount = tx.Amount,
                    TransactionDate = tx.TransactionDate,
                    CategorizationRule = rule,
                    UsedAt = now,
                    Source = CategorizationSource.Auto,
                };

                _context.CategorizationUsages.Add(usage);
                tx.CategoryId = rule.CategoryId;
                autoCategorized++;
            }

            if (autoCategorized == 0)
                return 0;

            rule.UsageCount += autoCategorized;
            rule.LastUsedAt = now;

            await _context.SaveChangesAsync(ct);
            return autoCategorized;
        }

        public async Task CleanupOrphanedRulesAsync(
            IReadOnlyCollection<int>? candidateRuleIds,
            CancellationToken ct = default
        )
        {
            if (candidateRuleIds == null || candidateRuleIds.Count == 0)
                return;

            var ruleIds = candidateRuleIds.Where(id => id > 0).Distinct().ToList();
            if (ruleIds.Count == 0)
                return;

            var existingRules = await _context
                .CategorizationRules.Where(r => ruleIds.Contains(r.Id))
                .Select(r => r.Id)
                .ToListAsync(ct);
            if (existingRules.Count == 0)
                return;

            var referenced = await _context
                .CategorizationUsages.Where(u => existingRules.Contains(u.CategorizationRuleId))
                .Select(u => u.CategorizationRuleId)
                .Distinct()
                .ToListAsync(ct);

            var referencedSet = referenced.ToHashSet();
            var orphanIds = existingRules.Where(id => !referencedSet.Contains(id)).ToList();
            if (orphanIds.Count == 0)
                return;

            var orphanRules = await _context
                .CategorizationRules.Where(r => orphanIds.Contains(r.Id))
                .ToListAsync(ct);

            _context.CategorizationRules.RemoveRange(orphanRules);
            await _context.SaveChangesAsync(ct);
        }

        // -------- Helpers --------

        private static bool MatchesSign(CategorizationRule h, bool isPositiveTxn)
        {
            // null = båda
            return h.IsPositive == null || h.IsPositive == isPositiveTxn;
        }

        private static bool IsDescriptionAutoGenerated(string description)
        {
            if (string.IsNullOrWhiteSpace(description))
                return false;

            // Villkor 1: All cap (minst 2 ord)
            if (description == description.ToUpper() && description.Trim().Contains(' '))
                return true;

            // Villkor 2: Slutar på ",XX" där XX är två versaler (landskod)
            if (
                description.Length >= 3
                && description[^3] == ','
                && char.IsUpper(description[^2])
                && char.IsUpper(description[^1])
            )
            {
                return true;
            }

            // Villkor 3: Innehåller " AB"
            if (description.Contains(" AB"))
                return true;

            return false;
        }

        private static SignRule GetSignRuleForGroup(string? groupKey)
        {
            return groupKey switch
            {
                "income" => SignRule.MustBePositive,
                "transfers" => SignRule.CanBeEither,
                "housing" => SignRule.MustBeNegative,
                "vehicle" => SignRule.MustBeNegative,
                "fixed-expenses" => SignRule.MustBeNegative,
                "variable-expenses" => SignRule.MustBeNegative,
                _ => SignRule.CanBeEither,
            };
        }

        private static string? ValidateAmountSign(decimal amount, Category category)
        {
            var group = category.Group;
            if (group == null)
                return null;

            var rule = GetSignRuleForGroup(group.Key);
            var isValid = rule switch
            {
                SignRule.MustBePositive => amount > 0,
                SignRule.MustBeNegative => amount < 0,
                SignRule.CanBeEither => true,
                _ => true,
            };

            if (isValid)
                return null;

            return $"Beloppet {amount} är inte giltigt för kategorigruppen '{group.DisplayName}'.";
        }

        public async Task<(
            bool Ok,
            string? Error,
            List<Transaction> Transactions
        )> ValidateSameSignAsync(IReadOnlyCollection<int> txIds, CancellationToken ct)
        {
            if (txIds.Count == 0)
                return (false, "No transaction IDs provided.", new List<Transaction>());

            var transactions = await _context
                .Transactions.Where(t => txIds.Contains(t.Id))
                .ToListAsync(ct);

            if (transactions.Count != txIds.Count)
                return (false, "One or more transactions not found.", transactions);

            var allPositive = transactions.All(t => t.Amount >= 0);
            var allNegative = transactions.All(t => t.Amount < 0);

            if (!(allPositive || allNegative))
                return (
                    false,
                    "Alla transaktioner måste ha samma tecken (positiva eller negativa).",
                    transactions
                );

            return (true, null, transactions);
        }
    }
}
