using Microsoft.EntityFrameworkCore;
using PiggyzenMvp.API.Data;
using PiggyzenMvp.API.Models;

namespace PiggyzenMvp.API.Services
{
    public record AutoCategorizeResult(int TransactionId, string? Error);

    public class CategorizationService
    {
        private readonly PiggyzenMvpContext _context;
        private readonly NormalizeService _normalize;

        public CategorizationService(PiggyzenMvpContext context, NormalizeService normalize)
        {
            _context = context;
            _normalize = normalize;
        }

        /// <summary>
        /// Manuell kategorisering av en transaktion (admin/UX-val).
        /// - Skapar eller uppdaterar en historikrad kopplad till manuellt val.
        /// - Säkerställer att Transaktionen och dess Usage pekar på den manuella regeln.
        /// </summary>
        public async Task<string?> CategorizeManuallyAsync(
            int transactionId,
            int categoryId,
            CancellationToken ct = default
        )
        {
            var t = await _context
                .Transactions.Include(x => x.CategorizationUsage)
                .ThenInclude(u => u.CategorizationRule)
                .FirstOrDefaultAsync(x => x.Id == transactionId, ct);

            if (t == null)
                return "Transaction not found.";

            if (t.CategoryId != null)
                return "Transaction is already categorized.";

            var categoryExists = await _context.Categories.AnyAsync(
                c => c.Id == categoryId,
                cancellationToken: ct
            );
            if (!categoryExists)
                return "Category not found.";

            var norm = t.NormalizedDescription;
            var isPos = t.Amount >= 0m;

            var candidateRules = await _context
                .CategorizationRules.Where(r =>
                    r.NormalizedDescription == norm && r.CategoryId == categoryId
                )
                .ToListAsync(ct);

            var history =
                candidateRules.FirstOrDefault(r => r.IsPositive == isPos)
                ?? candidateRules.FirstOrDefault(r => r.IsPositive == null);

            if (history == null)
            {
                var now = DateTime.UtcNow;
                history = new CategorizationRule
                {
                    Description = t.Description,
                    NormalizedDescription = norm,
                    IsDescriptionAutoGenerated = IsDescriptionAutoGenerated(t.Description),
                    IsPositive = isPos,
                    CategoryId = categoryId,
                    IsRefund = null,
                    Created = now,
                    UsageCount = 0,
                    LastUsedAt = null,
                };
                await _context.CategorizationRules.AddAsync(history, ct);
            }

            var nowTime = DateTime.UtcNow;

            if (t.CategorizationUsage != null)
                return "Internal error: Usage exists but transaction is uncategorized.";

            var usage = new CategorizationUsage
            {
                TransactionId = t.Id,
                Amount = t.Amount,
                TransactionDate = t.TransactionDate,
                CategorizationRule = history,
                UsedAt = nowTime,
                WasOverridden = null,
                Source = CategorizationSource.Manual,
            };
            _context.CategorizationUsages.Add(usage);

            // Håll Transaction i synk för snabba queries
            t.CategoryId = categoryId;

            history.UsageCount += 1;
            history.LastUsedAt = nowTime;

            await _context.SaveChangesAsync(ct);
            return null;
        }

        public async Task<string?> ChangeCategoryAsync(
            int transactionId,
            int newCategoryId,
            CancellationToken ct = default
        )
        {
            var tx = await _context
                .Transactions.Include(t => t.CategorizationUsage)
                .ThenInclude(u => u.CategorizationRule)
                .FirstOrDefaultAsync(t => t.Id == transactionId, ct);

            if (tx == null)
                return "Transaction not found.";

            if (tx.CategoryId == null)
                return "Transaction is not categorized yet.";

            if (tx.CategoryId == newCategoryId)
                return null;

            var categoryExists = await _context.Categories.AnyAsync(
                c => c.Id == newCategoryId,
                cancellationToken: ct
            );
            if (!categoryExists)
                return "Category not found.";

            var usage = tx.CategorizationUsage;
            if (usage == null)
                return "Internal error: transaction has no CategorizationUsage.";

            var oldRule = usage.CategorizationRule;
            if (oldRule == null)
                return "Internal error: transaction usage is missing CategorizationRule.";

            var normalized = tx.NormalizedDescription;
            var isPositive = tx.Amount >= 0m;

            var candidateRules = await _context
                .CategorizationRules.Where(r =>
                    r.NormalizedDescription == normalized && r.CategoryId == newCategoryId
                )
                .ToListAsync(ct);

            var matchedRule =
                candidateRules.FirstOrDefault(r => r.IsPositive == isPositive)
                ?? candidateRules.FirstOrDefault(r => r.IsPositive == null);

            var now = DateTime.UtcNow;

            if (matchedRule == null)
            {
                matchedRule = new CategorizationRule
                {
                    Description = tx.Description,
                    NormalizedDescription = normalized,
                    IsDescriptionAutoGenerated = IsDescriptionAutoGenerated(tx.Description),
                    IsPositive = isPositive,
                    CategoryId = newCategoryId,
                    IsRefund = null,
                    Created = now,
                    UsageCount = 0,
                    LastUsedAt = null,
                };

                await _context.CategorizationRules.AddAsync(matchedRule, ct);
            }

            usage.WasOverridden = now;
            usage.CategorizationRule = matchedRule;
            usage.UsedAt = now;
            usage.Source = CategorizationSource.Manual;

            tx.CategoryId = newCategoryId;

            if (oldRule.UsageCount > 0)
                oldRule.UsageCount -= 1;

            matchedRule.UsageCount += 1;
            matchedRule.LastUsedAt = now;

            var latestRemainingUsage = await _context
                .CategorizationUsages.Where(u =>
                    u.CategorizationRuleId == oldRule.Id && u.Id != usage.Id
                )
                .OrderByDescending(u => u.UsedAt)
                .Select(u => (DateTime?)u.UsedAt)
                .FirstOrDefaultAsync(ct);

            oldRule.LastUsedAt = latestRemainingUsage;

            await _context.SaveChangesAsync(ct);
            await CleanupOrphanedRulesAsync(new[] { oldRule.Id }, ct);
            return null;
        }

        /// <summary>
        /// Auto-kategoriserar en transaktion baserat på sparad historik/regler.
        /// Matchningsordning:
        ///  1) norm + tecken + beloppsintervall som inkluderar amount
        ///  2) norm + tecken (utan intervall)
        ///  3) norm (IsPositive=null i CH)
        /// </summary>
        public async Task<string?> CategorizeAutomaticallyAsync(
            string importId,
            CancellationToken ct = default
        )
        {
            var t = await _context
                .Transactions.Include(x => x.CategorizationUsage)
                .ThenInclude(u => u.CategorizationRule)
                .FirstOrDefaultAsync(x => x.ImportId == importId, ct);

            if (t == null)
                return $"Transaktion med ImportId \"{importId}\" hittades inte.";

            var norm = _normalize.Normalize(t.Description);
            var isPos = t.Amount >= 0m;

            // Kandidater på norm
            var candidates = await _context
                .CategorizationRules.Where(h => h.NormalizedDescription == norm)
                .ToListAsync(ct);

            if (candidates.Count == 0)
                return "Ingen historik matchar denna mottagare/beskrivning.";

            // Rangordna kandidater
            CategorizationRule? pick =
                candidates.FirstOrDefault(h => MatchesSign(h, isPos))
                ?? candidates.FirstOrDefault(h => h.IsPositive == null);

            if (pick == null)
                return "Ingen lämplig regel kunde väljas för auto-kategorisering.";

            // 1:1 usage (skapa/uppdatera)
            var u = t.CategorizationUsage;
            if (u == null)
            {
                u = new CategorizationUsage
                {
                    TransactionId = t.Id,
                    Amount = t.Amount,
                    TransactionDate = t.TransactionDate,
                    CategorizationRuleId = pick.Id,
                    UsedAt = DateTime.UtcNow,
                };
                _context.CategorizationUsages.Add(u);
            }
            else if (u.CategorizationRuleId != pick.Id)
            {
                u.WasOverridden = DateTime.UtcNow;
                u.CategorizationRuleId = pick.Id;
                u.UsedAt = DateTime.UtcNow;
                u.WasOverridden = null;
            }

            // Synka transaktionens kategori
            t.CategoryId = pick.CategoryId;

            await _context.SaveChangesAsync(ct);
            return null;
        }

        public async Task<IReadOnlyCollection<AutoCategorizeResult>> AutoCategorizeAsync(
            IReadOnlyCollection<int> transactionIds,
            CancellationToken ct = default
        )
        {
            if (transactionIds == null || transactionIds.Count == 0)
                return Array.Empty<AutoCategorizeResult>();

            var distinctIds = transactionIds.Distinct().ToList();
            var results = new List<AutoCategorizeResult>(distinctIds.Count);

            foreach (var id in distinctIds)
            {
                var error = await AutoCategorizeTransactionAsync(id, ct);
                results.Add(new AutoCategorizeResult(id, error));
            }

            return results;
        }

        private async Task<string?> AutoCategorizeTransactionAsync(
            int transactionId,
            CancellationToken ct
        )
        {
            var tx = await _context
                .Transactions.Include(t => t.CategorizationUsage)
                .ThenInclude(u => u.CategorizationRule)
                .FirstOrDefaultAsync(t => t.Id == transactionId, ct);

            if (tx == null)
                return "Transaction not found.";

            if (tx.CategoryId != null)
                return "Transaction is already categorized.";

            var normalized = tx.NormalizedDescription;
            var isPositive = tx.Amount >= 0m;

            var rules = await _context
                .CategorizationRules.Where(r => r.NormalizedDescription == normalized)
                .ToListAsync(ct);

            if (rules.Count == 0)
                return "No matching rules.";

            var autoRules = rules.Where(r => r.IsDescriptionAutoGenerated).ToList();
            if (autoRules.Count == 0)
                return "No auto-generated rules for this merchant.";

            var validRules = autoRules
                .Where(r => r.IsPositive == null || r.IsPositive == isPositive)
                .ToList();

            if (validRules.Count == 0)
                return "No rules matching sign.";

            CategorizationRule bestRule;
            if (validRules.Count == 1)
                bestRule = validRules[0];
            else
                bestRule = validRules.OrderByDescending(r => r.UsageCount).First();

            var now = DateTime.UtcNow;

            if (tx.CategorizationUsage == null)
            {
                var usage = new CategorizationUsage
                {
                    TransactionId = tx.Id,
                    Amount = tx.Amount,
                    TransactionDate = tx.TransactionDate,
                    CategorizationRule = bestRule,
                    UsedAt = now,
                    Source = CategorizationSource.Auto,
                };

                await _context.CategorizationUsages.AddAsync(usage, ct);
            }
            else
            {
                tx.CategorizationUsage.CategorizationRule = bestRule;
                tx.CategorizationUsage.UsedAt = now;
                tx.CategorizationUsage.Source = CategorizationSource.Auto;
                tx.CategorizationUsage.WasOverridden = null;
            }

            tx.CategoryId = bestRule.CategoryId;

            bestRule.UsageCount += 1;
            bestRule.LastUsedAt = now;

            await _context.SaveChangesAsync(ct);
            return null;
        }

        public async Task CleanupOrphanedRulesAsync(
            IReadOnlyCollection<int>? candidateRuleIds,
            CancellationToken ct = default
        )
        {
            if (candidateRuleIds == null || candidateRuleIds.Count == 0)
                return;

            var ruleIds = candidateRuleIds.Where(id => id > 0).Distinct().ToList();
            if (ruleIds.Count == 0)
                return;

            var existingRules = await _context
                .CategorizationRules.Where(r => ruleIds.Contains(r.Id))
                .Select(r => r.Id)
                .ToListAsync(ct);
            if (existingRules.Count == 0)
                return;

            var referenced = await _context
                .CategorizationUsages.Where(u => existingRules.Contains(u.CategorizationRuleId))
                .Select(u => u.CategorizationRuleId)
                .Distinct()
                .ToListAsync(ct);

            var referencedSet = referenced.ToHashSet();
            var orphanIds = existingRules.Where(id => !referencedSet.Contains(id)).ToList();
            if (orphanIds.Count == 0)
                return;

            var orphanRules = await _context
                .CategorizationRules.Where(r => orphanIds.Contains(r.Id))
                .ToListAsync(ct);

            _context.CategorizationRules.RemoveRange(orphanRules);
            await _context.SaveChangesAsync(ct);
        }

        // -------- Helpers --------

        private static bool MatchesSign(CategorizationRule h, bool isPositiveTxn)
        {
            // null = båda
            return h.IsPositive == null || h.IsPositive == isPositiveTxn;
        }

        private static bool IsDescriptionAutoGenerated(string description)
        {
            if (string.IsNullOrWhiteSpace(description))
                return false;

            // Villkor 1: All cap (minst 2 ord)
            if (description == description.ToUpper() && description.Trim().Contains(' '))
                return true;

            // Villkor 2: Innehåller ",XX"
            if (description.Contains(",") && description.Length > 3)
            {
                var parts = description.Split(',');
                if (parts.Length > 1 && parts[1].Length == 2 && int.TryParse(parts[1], out _))
                    return true;
            }

            // Villkor 3: Innehåller " AB"
            if (description.Contains(" AB"))
                return true;

            return false;
        }

        public async Task<(
            bool Ok,
            string? Error,
            List<Transaction> Transactions
        )> ValidateSameSignAsync(IReadOnlyCollection<int> txIds, CancellationToken ct)
        {
            if (txIds.Count == 0)
                return (false, "No transaction IDs provided.", new List<Transaction>());

            var transactions = await _context
                .Transactions.Where(t => txIds.Contains(t.Id))
                .ToListAsync(ct);

            if (transactions.Count != txIds.Count)
                return (false, "One or more transactions not found.", transactions);

            var allPositive = transactions.All(t => t.Amount >= 0);
            var allNegative = transactions.All(t => t.Amount < 0);

            if (!(allPositive || allNegative))
                return (
                    false,
                    "Alla transaktioner måste ha samma tecken (positiva eller negativa).",
                    transactions
                );

            return (true, null, transactions);
        }
    }
}
